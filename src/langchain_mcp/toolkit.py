import asyncio\\nimport warnings\\nfrom typing import Any, Callable, Optional\\n\\nimport pydantic\\nimport pydantic_core\\nimport typing_extensions as t\\nfrom langchain_core.tools.base import BaseTool, BaseToolkit, ToolException\\nfrom mcp import ClientSession, ListToolsResult, Tool\\n\\nclass MCPToolkit(BaseToolkit):\\n    """ MCP server toolkit """\\n\\n    session: ClientSession\\n    """ The MCP session used to obtain the tools """\\n\\n    _tools: List[BaseTool] = []\\n\\n    model_config = pydantic.ConfigDict(arbitrary_types_allowed=True)\\n\\n    async def initialize(self):\\n        """ Initialize the MCP session """\\n        if not self._initialized:\\n            await self.session.initialize()\\n            self._initialized = True\\n            self._tools = await self.get_tools()\\n\\n    async def get_tools(self) -> list[BaseTool]:\\n        """ Get the list of tools from the MCP session """\\n        if not self._initialized:\\n            await self.initialize()\\n\\n        return [\\n            MCPTool(\\n                toolkit=self,\\n                name=tool.name,\\n                description=tool.description or "",\\n                args_schema=create_schema_model(tool.inputSchema),\\n            )\\n            for tool in (await self.session.list_tools()).tools\\n        ]\\n\\nclass MCPTool(BaseTool):\\n    """ MCP server tool """\\n\\n    toolkit: MCPToolkit\\n    handle_tool_error: bool | str | Callable[[ToolException], str] | None = True\\n\\n    async def _arun(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\\n        """ Run the tool asynchronously """\\n        result = await self.toolkit.session.call_tool(self.name, arguments=kwargs)\\n        content = pydantic_core.to_json(result.content).decode()\\n        if result.isError:\\n            raise ToolException(content)\\n        return content\\n\\n    @property\\n    def tool_call_schema(self) -> type[pydantic.BaseModel]:\\n        assert self.args_schema is not None  # noqa: S101\\n        return self.args_schema\\n