import asyncio\nimport warnings\nfrom typing import Any, Callable, Optional\n\nimport pydantic\nimport pydantic_core\nimport typing_extensions as t\nfrom langchain_core.tools.base import BaseTool, BaseToolkit, ToolException\nfrom mcp import ClientSession, ListToolsResult, Tool\n\n# Copyright (C) 2024 Andrew Wason\n# SPDX-License-Identifier: MIT\n\nclass MCPToolkit(BaseToolkit):\n    \"\"\" MCP server toolkit \"\"\"\n\n    session: ClientSession\n    \"\"\" The MCP session used to obtain the tools \"\"\"\n\n    _tools: ListToolsResult | None = None\n\n    model_config = pydantic.ConfigDict(arbitrary_types_allowed=True)\n\n    async def initialize(self):\n        \"\"\" Initialize the MCP session and get the tools list \"\"\"\n        if not self._tools:\n            await self.session.initialize()\n            self._tools = await self.get_tools()\n\n    async def get_tools(self) -> list[BaseTool]:\n        \"\"\" Get the list of tools from the MCP session \"\"\"\n        tools_result = await self.session.list_tools()\n        if not tools_result:\n            raise RuntimeError('Failed to retrieve tools from MCP session.')\n        return [\n            MCPTool(\n                toolkit=self,\n                name=tool.name,\n                description=tool.description or "",\n                args_schema=create_schema_model(tool.inputSchema),\n            )\n            for tool in tools_result.tools\n        ]\n\nclass MCPTool(BaseTool):\n    \"\"\" MCP server tool \"\"\"\n\n    toolkit: MCPToolkit\n    handle_tool_error: bool | str | Callable[[ToolException], str] | None = True\n\n    async def _arun(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        \"\"\" Run the tool asynchronously \"\"\"\n        result = await self.toolkit.session.call_tool(self.name, arguments=kwargs)\n        content = pydantic_core.to_json(result.content).decode()\n        if result.isError:\n            raise ToolException(content)\n        return content\n\n    @property\n    def tool_call_schema(self) -> type[pydantic.BaseModel]:\n        assert self.args_schema is not None  # noqa: S101\n        return self.args_schema\n\ndef create_schema_model(schema: dict[str, t.Any]) -> type[pydantic.BaseModel]:\n    \"\"\" Create a schema model based on the input schema \"\"\"\n    class Schema(pydantic.BaseModel):\n        model_config = pydantic.ConfigDict(extra=\"allow\", arbitrary_types_allowed=True)\n\n        @t.override\n        @classmethod\n        def model_json_schema(cls, by_alias: bool = True, ref_template: str = pydantic.json_schema.DEFAULT_REF_TEMPLATE) -> dict[str, t.Any]:\n            return schema\n\n    return Schema\n