import asyncio\"\",\"import warnings\",\"from typing import Callable, Any, Dict, List, Type\",\"import pydantic\",\"import pydantic_core\",\"import typing_extensions as t\",\"from langchain_core.tools.base import BaseTool, BaseToolkit, ToolException\",\"from mcp import ClientSession, ListToolsResult, Tool, CallToolResult, TextContent\\\n\\\nclass MCPToolkit(BaseToolkit):\""" MCP server toolkit """\\\n    session: ClientSession\""" The MCP session used to obtain the tools """\\\n    _tools: List[BaseTool] = []\""" Store tools once retrieved """\\\n    _initialized: bool = False\""" Flag to check if toolkit is initialized """\\\n    model_config = pydantic.ConfigDict(arbitrary_types_allowed=True)\\\n    async def initialize(self):\""" Initialize the MCP toolkit. """\\\n        if not self._initialized:\\\n            await self.session.initialize()\\\n            self._initialized = True\\\n            self._tools = await self.get_tools()\\\n    async def get_tools(self) -> List[BaseTool]:\""" Get the list of tools from the MCP session. """\\\n        if not self._initialized:\\\n            raise RuntimeError("Must initialize the toolkit first.")\\\n        return [\\\n            MCPTool(\\\n                session=self.session,\\\n                name=tool.name,\\\n                description=tool.description or "",\\\n                args_schema=create_schema_model(tool.inputSchema),\\\n            )\\\n            for tool in (await self.session.list_tools()).tools\\\n        ]\\\n\\\ndef create_schema_model(schema: Dict[str, Any]) -> Type[pydantic.BaseModel]:\""" Create a Pydantic model from a JSON schema. """\\\n    class Schema(pydantic.BaseModel):\""" Pydantic model class for JSON schema. """\\\n        model_config = pydantic.ConfigDict(extra=\"allow\", arbitrary_types_allowed=True)\\\n        @classmethod\\\n        def model_json_schema(cls, by_alias: bool = True) -> Dict[str, Any]:\""" Generate JSON schema from the Pydantic model. """\\\n            return schema\\\n    return Schema\\\n\\\nclass MCPTool(BaseTool):\""" MCP server tool """\\\n    session: ClientSession\""" The MCP session used to obtain the tools """\\\n    handle_tool_error: bool | str | Callable[[ToolException], str] | None = True\""" Handle tool error behavior """\\\n    def __init__(self, session: ClientSession, name: str, description: str, args_schema: Type[pydantic.BaseModel]):\""" Initialize MCPTool. """\\\n        self.session = session\\\n        super().__init__(name=name, description=description, args_schema=args_schema)\\\n    async def _arun(self, *args: Any, **kwargs: Any) -> Any:\""" Run the tool asynchronously. """\\\n        result = await self.session.call_tool(self.name, arguments=kwargs)\\\n        content = pydantic_core.to_json(result.content).decode()\\\n        if result.isError:\\\n            raise ToolException(content)\\\n        return content\\\n    @property\\\n    def tool_call_schema(self) -> Type[pydantic.BaseModel]:\""" Get the tool call schema. """\\\n        assert self.args_schema is not None  # noqa: S101\\\n        return self.args_schema\\\n