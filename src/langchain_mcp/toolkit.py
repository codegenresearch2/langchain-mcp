python\# Copyright (C) 2024 Andrew Wason\\n# SPDX-License-Identifier: MIT\\\\\n\\nimport asyncio\\\\nimport warnings\\\\nfrom collections.abc import Callable\\\\n\\\\nimport pydantic\\\\nimport pydantic_core\\\\nimport typing_extensions as t\\\\nfrom langchain_core.tools.base import BaseTool, BaseToolkit, ToolException\\\\nfrom mcp import ClientSession\\\\n\\\\nclass MCPToolkit(BaseToolkit):\\\"""\\\\\n MCP server toolkit\\\""""\\\\\n\\\\n    session: ClientSession\\"""The MCP session used to obtain the tools"""\\\\\n\\\\n    _initialized: bool = False\\\\n\\\\n    model_config = pydantic.ConfigDict(arbitrary_types_allowed=True)\\\\n\\\\n    async def initialize(self):\\\"""\\\\\n    Initialize the toolkit before use.\\\""""\\\\\n        if not self._initialized:\\\\n            await self.session.initialize()\\\\n            self._initialized = True\\\\n\\\\n    @t.override\\\\n    async def get_tools(self) -> list[BaseTool]:  # type: ignore[override]"""\\\\\n        await self.initialize()\\\\n        return [\\\\n            MCPTool(\\\\n                toolkit=self,\\\\n                name=tool.name,\\\\n                description=tool.description or "",\\\\n                args_schema=create_schema_model(tool.inputSchema),\\\\n            )\\\\n            for tool in (await self.session.list_tools()).tools\\\\n        ]\\\\n\\\\n\\\\ndef create_schema_model(schema: dict[str, t.Any]) -> type[pydantic.BaseModel]:\\\"""\\\\\n Create a Pydantic model from the given JSON schema.\\\""""\\\\\n    class Schema(pydantic.BaseModel):\\\\n        model_config = pydantic.ConfigDict(extra="allow", arbitrary_types_allowed=True)\\\\n\\\\n        @t.override\\\\n        @classmethod\\\\n        def model_json_schema(\\\\n            cls,\\\\n            by_alias: bool = True,\\\\n            ref_template: str = pydantic.json_schema.DEFAULT_REF_TEMPLATE,\\\\n            schema_generator: type[pydantic.json_schema.GenerateJsonSchema] = pydantic.json_schema.GenerateJsonSchema,\\\\n            mode: pydantic.json_schema.JsonSchemaMode = "validation",\\\\n        ) -> dict[str, t.Any]:\\\\n            return schema\\\\n\\\\n    return Schema\\\\n\\\\n\\\\nclass MCPTool(BaseTool):\\"""\\\\\n MCP server tool\\\""""\\\\\n\\\\n    toolkit: MCPToolkit\\\\n    handle_tool_error: bool | str | Callable[[ToolException], str] | None = True\\\\n\\\\n    @t.override\\\\n    def _run(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\\\\n        warnings.warn(\\\\\"Invoke this tool asynchronousely using `ainvoke`. This method exists only to satisfy tests.", stacklevel=1)\\\\n        return asyncio.run(self._arun(*args, **kwargs))\\\\n\\\\n    @t.override\\\\n    async def _arun(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\\\\n        result = await self.toolkit.session.call_tool(self.name, arguments=kwargs)\\\\n        content = pydantic_core.to_json(result.content).decode()\\\\n        if result.isError:\\\\n            raise ToolException(content)\\\\n        return content\\\\n\\\\n    @t.override\\\\n    @property\\\\n    def tool_call_schema(self) -> type[pydantic.BaseModel]:\\\\n        assert self.args_schema is not None  # noqa: S101\\\\n        return self.args_schema\\\\n