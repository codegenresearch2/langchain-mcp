import asyncio\nimport warnings\nfrom typing import Callable, Any, Dict, List, Type\nimport pydantic\nimport pydantic_core\nimport typing_extensions as t\nfrom langchain_core.tools.base import BaseTool, BaseToolkit, ToolException\nfrom mcp import ClientSession, ListToolsResult, Tool, CallToolResult, TextContent\n\nclass MCPToolkit(BaseToolkit):\n    """ MCP server toolkit """\n\n    session: ClientSession\n    \"\"\" The MCP session used to obtain the tools """\n\n    _initialized: bool = False\n\n    model_config = pydantic.ConfigDict(arbitrary_types_allowed=True)\n\n    async def initialize(self):\n        """Initialize the MCP toolkit.\n\n        This method initializes the session and retrieves the tools if not already initialized.\n        \"\"\"\n        if not self._initialized:\n            await self.session.initialize()\n            self._initialized = True\n\n    async def get_tools(self) -> List[BaseTool]:\n        """Get the list of tools from the MCP session.\n\n        This method retrieves the tools from the MCP session and returns them as a list of BaseTool objects.\n        \"\"\"\n        if not self._initialized:\n            raise RuntimeError("MCPToolkit has not been initialized.")\n\n        tools = (await self.session.list_tools()).tools\n        return [\n            MCPTool(\n                session=self.session,\n                name=tool.name,\n                description=tool.description or "",\n                args_schema=create_schema_model(tool.inputSchema),\n            )\n            for tool in tools\n        ]\n\ndef create_schema_model(schema: Dict[str, Any]) -> Type[pydantic.BaseModel]:\n    class Schema(pydantic.BaseModel):\n        model_config = pydantic.ConfigDict(extra="allow", arbitrary_types_allowed=True)\n\n        @classmethod\n        def model_json_schema(cls, by_alias: bool = True) -> Dict[str, Any]:\n            return schema\n\n    return Schema\n\nclass MCPTool(BaseTool):\n    """ MCP server tool """\n\n    session: ClientSession\n    \"\"\" The MCP session used to obtain the tools """\n    handle_tool_error: bool | str | Callable[[ToolException], str] | None = True\n\n    def __init__(self, session: ClientSession, name: str, description: str, args_schema: Type[pydantic.BaseModel]):\n        self.session = session\n        super().__init__(name=name, description=description, args_schema=args_schema)\n\n    async def _arun(self, *args: Any, **kwargs: Any) -> Any:\n        """Run the tool asynchronously.\n\n        This method calls the tool with the given arguments and returns the result.\n        \"\"\"\n        result = await self.session.call_tool(self.name, arguments=kwargs)\n        content = pydantic_core.to_json(result.content).decode()\n        if result.isError:\n            raise ToolException(content)\n        return content\n\n    @property\n    def tool_call_schema(self) -> Type[pydantic.BaseModel]:\n        assert self.args_schema is not None  # noqa: S101\n        return self.args_schema\n